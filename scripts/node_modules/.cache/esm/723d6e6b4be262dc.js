_4be‍.x([["Banco",()=>Banco]]);class Banco {
    constructor(codigoBanco) {
        this.codigoBanco = codigoBanco;
    }
    formatarValorCelula(celula, valor) {
        let charARepetir = celula.mascara[0] == '9' ? '0' : ' ';
        if (valor.length > celula.tamanho)
            return valor.slice(0, celula.tamanho);
        else if (valor.length < celula.tamanho)
            if (celula.preenchimento) {
                if (!celula.preenchimento.caractere)
                    celula.preenchimento.caractere = charARepetir;
                return celula.preenchimento.posicao == 'direita' ?
                    valor + celula.preenchimento.caractere.repeat(celula.tamanho - valor.length)
                    : celula.preenchimento.caractere.repeat(celula.tamanho - valor.length) + valor;
            }
            else
                return charARepetir.repeat(celula.tamanho - valor.length) + valor;
        return valor;
    }
    validarMascara(celula) {
        //Tipo de caractere aceito pelo campo
        let tipo = celula.mascara[0] == 'X' ? 'char' : celula.mascara[0] == '9' ? 'number' : '';
        if (!tipo)
            return false;
        //Quantidade de caracteres máx aceita pelo campo
        let qtdDigitos = Number(/\((\d*)\)/.exec(celula.mascara)[1]);
        //Qtd de digitos decimais a se considerar, quando campos usados se referem a valores
        let precisaoDecimal = celula.mascara.indexOf('V') != -1 ? /V(\d*)/.exec(celula.mascara)[1].length : 0;
        if (tipo == 'char')
            return (celula.tamanho == celula.valor.length && celula.tamanho == qtdDigitos);
        return (celula.tamanho == celula.valor.length
            && celula.tamanho == /\d*/.exec(celula.valor)[0].length
            && celula.tamanho == (qtdDigitos + precisaoDecimal));
    }
}
